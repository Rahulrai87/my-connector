import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Client } from '@microsoft/microsoft-graph-client';

@Injectable()
export class SharePointSyncService {
  private readonly logger = new Logger(SharePointSyncService.name);

  constructor(
    @InjectModel('SharePointFile')
    private readonly fileModel: Model<any>,
    private readonly graphClient: Client, // injected graph client
  ) {}

  /* ============================================================
     PUBLIC API
     ============================================================ */

  async nextSync(params: {
    connectorId: string;
    siteId: string;
    listId: string;
    rootItemId: string;
  }) {
    const { connectorId, siteId, listId, rootItemId } = params;

    // 1️⃣ Fetch SharePoint metadata
    const spItems = await this.fetchAllFromSharePoint(
      siteId,
      listId,
      rootItemId,
    );

    // 2️⃣ Fetch DB metadata
    const dbItems = await this.fetchAllFromDb(connectorId);

    // 3️⃣ Diff
    return this.diff(spItems, dbItems);
  }

  /* ============================================================
     SHAREPOINT FETCH
     ============================================================ */

  private async fetchAllFromSharePoint(
    siteId: string,
    listId: string,
    rootItemId: string,
  ) {
    // Resolve driveId from list
    const drive = await this.graphClient
      .api(`/sites/${siteId}/lists/${listId}/drive`)
      .get();

    const driveId = drive.id;
    const result: any[] = [];

    await this.walkRecursive(driveId, rootItemId, '', result);

    return result;
  }

  private async walkRecursive(
    driveId: string,
    itemId: string,
    basePath: string,
    out: any[],
  ) {
    const res = await this.graphClient
      .api(`/drives/${driveId}/items/${itemId}/children`)
      .get();

    for (const item of res.value) {
      const path = `${basePath}/${item.name}`;

      out.push({
        itemId: item.id,
        name: item.name,
        path,
        eTag: item.eTag,
        isFolder: !!item.folder,
        lastModifiedDateTime: item.lastModifiedDateTime,
      });

      if (item.folder) {
        await this.walkRecursive(driveId, item.id, path, out);
      }
    }
  }

  /* ============================================================
     DB FETCH
     ============================================================ */

  private async fetchAllFromDb(connectorId: string) {
    return this.fileModel
      .find({ connectorId })
      .lean();
  }

  /* ============================================================
     DIFF ENGINE
     ============================================================ */

  private diff(spItems: any[], dbItems: any[]) {
    const spMap = new Map<string, any>();
    const dbMap = new Map<string, any>();

    spItems.forEach(i => spMap.set(i.itemId, i));
    dbItems.forEach(i => dbMap.set(i.itemId, i));

    const created: any[] = [];
    const updated: any[] = [];
    const deleted: any[] = [];

    // Created / Updated
    for (const [itemId, spItem] of spMap) {
      const dbItem = dbMap.get(itemId);

      if (!dbItem) {
        created.push(spItem);
        continue;
      }

      if (dbItem.eTag !== spItem.eTag) {
        updated.push(spItem);
      }
    }

    // Deleted
    for (const [itemId, dbItem] of dbMap) {
      if (!spMap.has(itemId)) {
        deleted.push(dbItem);
      }
    }

    return {
      created,
      updated,
      deleted,
    };
  }
}
