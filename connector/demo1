import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Client } from '@microsoft/microsoft-graph-client';

@Injectable()
export class SharePointSyncService {
  private readonly logger = new Logger(SharePointSyncService.name);

  constructor(
    @InjectModel('SharePointFile')
    private readonly spFileModel: Model<any>,
    private readonly graphClient: Client,
  ) {}

  /* =====================================================
     PUBLIC ENTRY
     ===================================================== */

  async nextSync(
    connectorId: string,
    siteId: string,
    listId: string,
    rootItemId: string,
  ) {
    // 1️⃣ Fetch SharePoint → array
    const spItems = await this.fetchAllFromSharePoint(
      siteId,
      listId,
      rootItemId,
    );

    // 2️⃣ Fetch DB → array
    const dbItems = await this.fetchAllFromDb(connectorId);

    // 3️⃣ Compare
    return this.diff(spItems, dbItems);
  }

  /* =====================================================
     SHAREPOINT FETCH
     ===================================================== */

  private async fetchAllFromSharePoint(
    siteId: string,
    listId: string,
    rootItemId: string,
  ) {
    // Resolve driveId from list
    const drive = await this.graphClient
      .api(`/sites/${siteId}/lists/${listId}/drive`)
      .get();

    const driveId = drive.id;
    const result: any[] = [];

    await this.walkRecursive(driveId, rootItemId, '', result);
    return result;
  }

  private async walkRecursive(
    driveId: string,
    itemId: string,
    basePath: string,
    out: any[],
  ) {
    const res = await this.graphClient
      .api(`/drives/${driveId}/items/${itemId}/children`)
      .get();

    for (const item of res.value) {
      const filePath = `${basePath}/${item.name}`;

      out.push({
        itemId: item.id, // runtime only
        eTag: item.eTag,
        fileName: item.name,
        filePath,
        lastModifiedDateTime: item.lastModifiedDateTime,
      });

      if (item.folder) {
        await this.walkRecursive(
          driveId,
          item.id,
          filePath,
          out,
        );
      }
    }
  }

  /* =====================================================
     DB FETCH
     ===================================================== */

  private async fetchAllFromDb(connectorId: string) {
    return this.spFileModel
      .find({ connectorId })
      .lean();
  }

  /* =====================================================
     DIFF ENGINE
     ===================================================== */

  private diff(spItems: any[], dbItems: any[]) {
    /**
     * DB schema:
     * connectorId, eTag, filePath, fileName, lastModifiedDateTime
     *
     * Identity = filePath
     * Update detection = eTag OR lastModifiedDateTime
     */

    const spMap = new Map<string, any>();
    const dbMap = new Map<string, any>();

    spItems.forEach(i => spMap.set(i.filePath, i));
    dbItems.forEach(i => dbMap.set(i.filePath, i));

    const created: any[] = [];
    const updated: any[] = [];
    const deleted: any[] = [];

    // Created / Updated
    for (const [filePath, spItem] of spMap) {
      const dbItem = dbMap.get(filePath);

      if (!dbItem) {
        created.push(spItem);
        continue;
      }

      if (
        dbItem.eTag !== spItem.eTag ||
        dbItem.lastModifiedDateTime !== spItem.lastModifiedDateTime
      ) {
        updated.push(spItem);
      }
    }

    // Deleted
    for (const [filePath, dbItem] of dbMap) {
      if (!spMap.has(filePath)) {
        deleted.push(dbItem);
      }
    }

    return {
      created,
      updated,
      deleted,
    };
  }
}
